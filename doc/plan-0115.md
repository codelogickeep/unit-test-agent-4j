# 逐函数单测生成流程增强计划

**日期**: 2026-01-15
**版本**: 1.1.0

## 1. 需求概述

实现逐函数生成单测的精细化流程：
1. 分析目标类的所有函数，识别核心函数
2. 获取函数级别的覆盖率
3. 按优先级逐个函数执行：生成单测 → LSP检查 → 编译 → 运行单测
4. 达到条件后再进行下一个函数

## 2. 现有能力

### 2.1 CodeAnalyzerTool
- `analyzeClass(path)` - 分析类结构
- `analyzeMethod(path, methodName)` - 分析方法复杂度和依赖
- `getMethodsForTesting(path)` - 获取需测试的方法列表（含复杂度）

### 2.2 CoverageTool
- `getMethodCoverageDetails(modulePath, className)` - 获取函数级别覆盖率 ✓
- `getUncoveredMethodsCompact(modulePath, className, threshold)` - 获取未覆盖方法
- `getUncoveredMethodsList(modulePath, className, threshold)` - 结构化未覆盖方法列表

## 3. 增强方案

### 3.1 增强 CodeAnalyzerTool - 添加核心函数识别

新增工具方法：`getPriorityMethods(path)`

```java
@Tool("Analyze methods and return prioritized list for testing, identifying core functions")
public String getPriorityMethods(@P("Path to the Java source file") String path)
```

**核心函数判断标准**：
- **高优先级 (P0)**:
  - 圈复杂度 >= 5
  - 有参数验证逻辑
  - 是公共 API (public 方法)
  - 被多个其他方法调用（核心逻辑）
  - 方法名包含关键词: process, calculate, validate, execute, handle

- **中优先级 (P1)**:
  - 圈复杂度 3-4
  - protected 方法
  - getter/setter 除外

- **低优先级 (P2)**:
  - 简单 getter/setter
  - 构造函数（无复杂逻辑）
  - 委托方法

**输出格式**：
```
Priority Methods for Testing:

P0 (Core Functions):
  1. processPayment(PaymentRequest) : Result [complexity:8, public, dependencies:3]
  2. validateAmount(BigDecimal) : boolean [complexity:5, public, dependencies:1]

P1 (Standard Methods):
  1. setConfig(Config) : void [complexity:2, public]

P2 (Low Priority):
  1. getStatus() : String [complexity:1, getter]

Recommended Order: processPayment → validateAmount → setConfig → getStatus
```

### 3.2 增强 CoverageTool - 添加单方法覆盖率快速查询

新增工具方法：`getSingleMethodCoverage(modulePath, className, methodName)`

```java
@Tool("Get coverage for a single method (fast check)")
public String getSingleMethodCoverage(
    @P("Path to the module directory") String modulePath,
    @P("Fully qualified class name") String className,
    @P("Method name to check") String methodName)
```

### 3.3 创建 MethodIteratorTool - 逐函数迭代控制器

新工具类，负责管理迭代状态：

```java
public class MethodIteratorTool implements AgentTool {
    
    private String targetClass;
    private List<String> methodQueue;  // 待处理方法队列
    private String currentMethod;       // 当前处理的方法
    private Map<String, String> methodStatus;  // 方法状态记录
    
    @Tool("Initialize method iteration for a target class")
    public String initMethodIteration(
        @P("Path to the source file") String sourcePath,
        @P("Path to the module directory") String modulePath,
        @P("Fully qualified class name") String className,
        @P("Coverage threshold") int threshold)
    
    @Tool("Get the next method to test")
    public String getNextMethod()
    
    @Tool("Mark current method as completed and report status")
    public String completeCurrentMethod(
        @P("Status: PASS, FAIL, or SKIP") String status,
        @P("Coverage achieved") double coverage,
        @P("Notes") String notes)
    
    @Tool("Get iteration progress summary")
    public String getIterationProgress()
}
```

### 3.4 更新系统提示词

添加迭代模式流程说明：

```
### Iterative Method Testing Mode

When iterative mode is enabled, follow this per-method workflow:

1. **Initialize**: Call `initMethodIteration` to analyze and prioritize methods
2. **Loop** (for each method):
   a. Call `getNextMethod` to get the next method to test
   b. If no more methods → go to step 3
   c. Generate test method(s) for this specific method only
   d. Call `checkSyntax` to verify the code
   e. If syntax errors → fix and retry step d
   f. Call `compileProject` to compile
   g. If compile errors → fix and retry step d
   h. Call `executeTest` to run tests
   i. Call `getSingleMethodCoverage` to check this method's coverage
   j. Call `completeCurrentMethod` with status and coverage
   k. Go to step 2.a
3. **Summary**: Call `getIterationProgress` to report final status
```

### 3.5 配置扩展

在 `AppConfig.WorkflowConfig` 中添加：

```yaml
workflow:
  iterative-mode: true       # 启用逐函数迭代模式
  method-coverage-threshold: 80  # 单个方法覆盖率阈值
  skip-low-priority: false   # 是否跳过低优先级方法
```

## 4. 实现步骤

### Phase 1: 核心函数识别 (CodeAnalyzerTool)
- [ ] 实现 `getPriorityMethods` 方法
- [ ] 添加方法调用图分析（识别被调用次数）
- [ ] 添加关键词匹配逻辑

### Phase 2: 单方法覆盖率 (CoverageTool)
- [ ] 实现 `getSingleMethodCoverage` 方法

### Phase 3: 迭代控制器 (MethodIteratorTool)
- [ ] 创建 `MethodIteratorTool` 类
- [ ] 实现状态管理
- [ ] 实现进度报告

### Phase 4: 系统集成
- [ ] 更新 `agent.yml` 配置
- [ ] 更新 `AppConfig` 
- [ ] 更新 `system-prompt.st`
- [ ] 更新 `DynamicPromptBuilder`

### Phase 5: 测试验证
- [ ] 单元测试
- [ ] 集成测试（使用示例项目）

## 5. 预期效果

### 5.1 改进前
```
[全量生成] 生成所有方法的测试 → 编译 → 运行 → 修复 → 再运行...
问题: 一次生成大量代码，错误定位困难
```

### 5.2 改进后
```
[逐函数] 
  processPayment: 生成 → 语法检查 ✓ → 编译 ✓ → 运行 ✓ → 覆盖率 85% ✓
  validateAmount: 生成 → 语法检查 ✓ → 编译 ✓ → 运行 ✓ → 覆盖率 90% ✓
  ...
优势: 即时反馈，问题易定位，节省 token
```

## 6. 版本记录

| 日期 | 版本 | 说明 |
|------|------|------|
| 2026-01-15 | 1.1.0 | 逐函数单测生成流程增强计划 |
